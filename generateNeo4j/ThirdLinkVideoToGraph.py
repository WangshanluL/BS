
data = [
        {"title": "1.1.1+1.1.3 操作系统的概念、功能", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=2",
         "video_word": ["核心功能"]},
        {"title": "1.1.2 操作系统的特征", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=3",
         "video_word": ["基本特性"]},
        {"title": "1.2_操作系统的发展与分类", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=4",
         "video_word": ["阶段"]},
        {"title": "1.3.1_操作系统的运行机制", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=5",
         "video_word": ["模式"]},
        {"title": "1.3.2_中断和异常", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=6",
         "video_word": ["中断与异常"]},
        {"title": "1.3.3_系统调用", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=7",
         "video_word": ["系统调用"]},
        {"title": "1.4_操作系统体系结构（上）", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=8",
         "video_word": ["架构类型"]},
        {"title": "1.4_操作系统体系结构（下）", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=9",
         "video_word": ["架构类型"]},
        {"title": "1.5_操作系统引导", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=10",
         "video_word": ["装入方式"]},
        {"title": "1.6_虚拟机", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=11", "video_word": ["特性"]},
        {"title": "2.1.1+2.1.2_进程的概念、组成、特征", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=12",
         "video_word": ["进程定义", "进程组成"]},
        {"title": "2.1.3_进程的状态与转换", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=13",
         "video_word": ["进程状态"]},
        {"title": "2.1.4_进程控制", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=14",
         "video_word": ["进程控制"]},
        {"title": "2.1.5_进程通信", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=15",
         "video_word": ["进程通信"]},
        {"title": "2.1.6_1 线程的概念与特点", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=16",
         "video_word": ["线程定义"]},
        {"title": "2.1.6_2 线程的实现方式和多线程模型", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=17",
         "video_word": ["实现方式"]},
        {"title": "2.1.6_3 线程的状态与转换", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=18",
         "video_word": ["线程定义"]},
        {"title": "2.2.1 调度的概念、层次", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=19",
         "video_word": ["高级调度", "中级调度", "低级调度"]},
        {"title": "2.2.2_1+2.2.4进程调度的时机、切换与过程、方式",
         "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=20", "video_word": ["非抢占调度", "抢占调度"]},
        {"title": "2.2.2_2 调度器和闲逛进程", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=21",
         "video_word": ["低级调度"]},
        {"title": "2.2.3 调度的目标（调度算法的评价指标）", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=22",
         "video_word": ["资源利用率", "系统吞吐量", "公平性", "响应时间", "周转时间"]},
        {"title": "2.2.5_1 调度算法：先来先服务、最短作业优先、最高响应比优先",
         "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=23",
         "video_word": ["先来先服务", "短作业优先", "高响应比优先"]},
        {"title": "2.2.5_2 调度算法：时间片轮转、优先级、多级反馈队列",
         "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=24",
         "video_word": ["轮转调度", "优先级调度", "多级反馈队列"]},
        {"title": "2.2.5_3 调度算法：多级队列调度算法", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=25",
         "video_word": ["多级反馈队列"]},
        {"title": "2.3.1 同步与互斥的基本概念", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=26",
         "video_word": ["临界资源", "临界区", "同步准则"]},
        {"title": "2.3.2_1 进程互斥的软件实现方法", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=27",
         "video_word": ["软件机制"]},
        {"title": "2.3.2_2 进程互斥的硬件实现方法", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=28",
         "video_word": ["硬件机制"]},
        {"title": "2.3.3_互斥锁", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=29", "video_word": ["临界区"]},
        {"title": "2.3.4_1 信号量机制", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=30",
         "video_word": ["硬件机制"]},
        {"title": "2.3.4_2 用信号量实现进程互斥、同步、前驱关系",
         "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=31", "video_word": ["硬件机制"]},
        {"title": "2.3.5_1 生产者-消费者问题", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=32",
         "video_word": ["生产者消费者"]},
        {"title": "2.3.5_2 多生产者-多消费者问题", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=33",
         "video_word": ["生产者消费者"]},
        {"title": "2.3.5_3 吸烟者问题", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=34",
         "video_word": ["临界资源"]},
        {"title": "2.3.5_4 读者-写者问题", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=35",
         "video_word": ["读者写者"]},
        {"title": "2.3.5_5 哲学家进餐问题", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=36",
         "video_word": ["哲学家进餐"]},
        {"title": "2.3.6 管程", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=37", "video_word": ["管程"]}
]
data += [
  {"title": "2.4.1 死锁的概念", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=38", "video_word": ["死锁原因", "死锁必要条件"]},
  {"title": "2.4.2 死锁的处理策略—预防死锁", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=39", "video_word": ["死锁处理"]},
  {"title": "2.4.3 死锁的处理策略—避免死锁", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=40", "video_word": ["死锁处理"]},
  {"title": "2.4.4 死锁的处理策略—检测和解除", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=41", "video_word": ["死锁处理"]},
  {"title": "3.1.1_1 内存的基础知识", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=42", "video_word": ["存储设备"]},
  {"title": "3.1.1_2 内存管理的概念", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=43", "video_word": ["局部性原理"]},
  {"title": "3.1.1_4 (选修）覆盖与交换", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=44", "video_word": ["特性"]},
  {"title": "3.1.2_1 连续分配管理方式", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=45", "video_word": ["连续分配"]},
  {"title": "3.1.2_2 动态分区分配算法", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=46", "video_word": ["分配策略"]},
  {"title": "3.1.3_1 基本分页存储管理的概念", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=47", "video_word": ["离散分配"]},
  {"title": "3.1.3_2 基本地址变换机构", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=48", "video_word": ["分页机制"]},
  {"title": "3.1.3_3 具有快表的地址变换机构", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=49", "video_word": ["分页机制"]},
  {"title": "3.1.3_4 两级页表", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=50", "video_word": ["分页机制"]},
  {"title": "3.1.4 基本分段存储管理方式", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=51", "video_word": ["离散分配"]},
  {"title": "3.1.5 段页式管理方式", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=52", "video_word": ["离散分配"]},
  {"title": "3.2.1 虚拟内存的基本概念", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=53", "video_word": ["特性"]},
  {"title": "3.2.2 请求分页管理方式", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=54", "video_word": ["页面分配"]},
  {"title": "3.2.4 页面置换算法", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=55", "video_word": ["置换算法"]},
  {"title": "3.2.5+3.2.3 页面分配策略", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=56", "video_word": ["页面分配", "性能问题"]},
  {"title": "3.2_5_内存映射文件", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=57", "video_word": ["特性"]},
  {"title": "4.1_1_初识文件管理", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=58", "video_word": ["文件定义", "文件分类"]},
  {"title": "4.1_2_文件的逻辑结构", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=59", "video_word": ["逻辑结构"]},
  {"title": "4.1_3_文件目录", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=60", "video_word": ["目录组织", "索引机制"]},
  {"title": "4.1_4_文件的物理结构（上）", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=61", "video_word": ["连续组织"]},
  {"title": "4.1_4_文件的物理结构（下）", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=62", "video_word": ["链接组织", "索引组织"]},
  {"title": "4.1_5_逻辑结构VS物理结构", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=63", "video_word": ["逻辑结构"]},
  {"title": "4.1_6_文件存储空间管理", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=64", "video_word": ["空闲区表法", "空闲链表法", "位示图法", "成组链接法"]},
  {"title": "4.1_7_文件的基本操作", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=65", "video_word": ["核心功能"]},
  {"title": "4.1_8_文件共享", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=66", "video_word": ["共享方式"]},
  {"title": "4.1_9_文件保护", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=67", "video_word": ["访问控制"]},
  {"title": "4.3_1_文件系统的层次结构", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=68", "video_word": ["层次结构"]},
  {"title": "4.3_2_文件系统布局", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=69", "video_word": ["层次结构"]},
  {"title": "4.3_4_虚拟文件系统", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=70", "video_word": ["特性"]},
  {"title": "5.1_1_I-O设备的概念和分类", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=71", "video_word": ["IO设备"]},
  {"title": "5.1.2_I-O控制器", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=72", "video_word": ["设备控制器"]},
  {"title": "5.1_3_IO控制方式", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=73", "video_word": ["轮询IO", "中断IO", "DMA", "通道控制"]},
  {"title": "5.1_4_I-O软件层次结构", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=74", "video_word": ["设备无关软件"]},
  {"title": "5.1_5_输入输出应用程序接口和驱动程序接口", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=75", "video_word": ["功能"]},
  {"title": "5.2_1_IO核心子系统", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=76", "video_word": ["功能"]},
  {"title": "5.2_2_假脱机技术", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=77", "video_word": ["SPOOLing系统"]},
  {"title": "5.2_3_设备的分配与回收", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=78", "video_word": ["设备无关软件"]},
  {"title": "5.2_4_缓冲区管理", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=79", "video_word": ["磁盘缓存"]},
  {"title": "5.3_1_磁盘的结构", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=80", "video_word": ["存储设备"]},
  {"title": "5.3_2_磁盘调度算法", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=81", "video_word": ["优化方法"]},
  {"title": "5.3_3_减少磁盘延迟时间的方法", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=82", "video_word": ["优化方法"]},
  {"title": "5.3_4_磁盘的管理", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=83", "video_word": ["RAID", "容错技术"]},
  {"title": "5.3_5_固态硬盘SSD", "url": "https://www.bilibili.com/video/BV1YE411D7nH?p=84", "video_word": ["存储设备"]}
]

import json
from neo4j import GraphDatabase


# 连接到Neo4j数据库
def connect_to_neo4j(uri="bolt://localhost:7687", username="neo4j", password="123456789"):
    try:
        driver = GraphDatabase.driver(uri, auth=(username, password))
        print("已连接到Neo4j数据库")
        return driver
    except Exception as e:
        print(f"连接Neo4j失败: {e}")
        return None


# 关闭Neo4j连接的函数
def close_neo4j_connection(driver):
    if driver is not None:
        driver.close()
        print("Neo4j连接已关闭")


# 执行Cypher查询
def run_cypher_query(driver, query, params=None):
    if params is None:
        params = {}

    with driver.session() as session:
        try:
            result = session.run(query, params)
            return result
        except Exception as e:
            print(f"查询执行失败: {e}")
            print(f"查询语句: {query}")
            return None


# 获取当前视频计数
def get_video_count(driver):
    query = """
    MATCH (video:VideoNode)
    RETURN COUNT(video) AS count
    """
    result = run_cypher_query(driver, query)
    if result:
        record = result.single()
        if record:
            return record["count"] + 1
    return 1


# 创建视频节点
def create_video_node(driver, video_data, video_counter):
    try:
        # 从数据中获取视频信息
        title = video_data.get("title", "").replace('"', '\\"')  # 转义双引号
        url = video_data.get("url", "").replace('"', '\\"')  # 转义双引号

        # 添加视频编号前缀
        video_name = f"视频{video_counter}:{title}"

        # 为VideoNode创建一个唯一的ID（使用title的安全版本）
        safe_video_name = video_name.replace(" ", "_").replace('"', '')

        # 创建视频节点的Cypher查询
        query = f"""
        CREATE (video:VideoNode {{
            video_name: "{video_name}",
            title: "{title}",
            url: "{url}"
        }})
        RETURN video
        """

        # 执行查询并获取结果
        result = run_cypher_query(driver, query)
        if result:
            print(f"成功创建视频节点: {video_name}")
            return safe_video_name, video_name
        else:
            print(f"创建视频节点失败: {video_name}")
            return None, video_name

    except Exception as e:
        print(f"创建视频节点时出错: {e}")
        return None, video_data.get("title", "")


# 建立视频与知识点之间的关系
def create_video_concept_relationships(driver, safe_video_name, video_name, video_words):
    try:
        if not video_words:
            print(f"视频 {safe_video_name} 没有关联的知识点")
            return

        for concept in video_words:
            # 创建关系的Cypher查询
            query = f"""
            MATCH (concept:ConceptNode {{concept_name: "{concept}"}}),
                  (video:VideoNode {{video_name: "{video_name}"}})
            CREATE (concept)-[:HAS_VIDEO]->(video)
            """

            result = run_cypher_query(driver, query)
            if result:
                print(f"成功创建关系: 知识点[{concept}] -> 视频[{video_name}]")
            else:
                print(f"创建关系失败: 知识点[{concept}] -> 视频[{video_name}]")

                # 如果创建关系失败，可能是因为ConceptNode不存在，可以选择创建一个
                create_concept_query = f"""
                CREATE (concept:ConceptNode {{
                    concept_name: "{concept}",
                    description: "自动创建的知识点节点"
                }})
                """

                # 执行创建知识点节点的查询
                run_cypher_query(driver, create_concept_query)
                print(f"已创建新的知识点节点: {concept}")

                # 再次尝试创建关系
                run_cypher_query(driver, query)
                print(f"重新尝试创建关系: 知识点[{concept}] -> 视频[{video_name}]")

    except Exception as e:
        print(f"创建视频与知识点关系时出错: {e}")


# 处理视频数据
def process_videos(driver, videos_data):
    try:
        # 获取当前视频计数作为起始值
        video_counter = 0
        print(f"开始处理，起始视频编号: {video_counter}")

        # 处理每个视频
        for video_data in videos_data:
            # 创建视频节点
            safe_video_name, video_name = create_video_node(driver, video_data, video_counter)
            video_counter += 1

            if safe_video_name:
                # 获取视频关联的知识点列表
                video_words = video_data.get("video_word", [])

                # 创建与知识点的关系
                create_video_concept_relationships(driver, safe_video_name, video_name, video_words)

        print(f"处理完成，共处理了 {len(videos_data)} 个视频数据")

    except Exception as e:
        print(f"处理视频数据时出错: {e}")





# 主程序执行
if __name__ == "__main__":
    # 文件路径
    file_path = "videos_data.txt"  # 请替换为你的视频数据文件路径

    # 连接到Neo4j
    driver = connect_to_neo4j()

    if driver:
        # 读取视频数据



            # 处理视频数据
        process_videos(driver, data)


        # 关闭Neo4j连接
        close_neo4j_connection(driver)